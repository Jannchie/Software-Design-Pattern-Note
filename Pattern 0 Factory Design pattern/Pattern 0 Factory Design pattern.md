### Pattern 0 ：Simple Factory Design Pattern 简单工厂设计模式

#### Summary——概述

**工厂设计模式**是一种非常常见的设计模式。这种设计模式常用以负责创建对象。

工厂设计模式可以细分为两种，分别为：工厂方法模式、抽象工厂模式。这里首先介绍简单工厂模式。

---

#### When——何时使用工厂模式

作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。

---

#### Why——为什么要使用工厂

工厂模式实际上会增加我们的代码量和设计难度，下面我将通过一个例子来引出工厂模式的优点，从而理解为什么要使用工厂。

##### Example：一个现实生活中工厂的例子

假设这个世界上没有工厂会怎么样？现在假如你是一个客户，你需要一辆汽车。由于没有专门制造汽车的工厂，你唯有自己组装一辆汽车，别无他法。此时的你需要了解到组装汽车的具体实现过程，而这给客户增加了负担，这不是我们想要的结果。

更加糟糕的是，当我们需要创建一个新的车型的时候，我们可能需要大量地修改系统中原来的方法，同时添加各种各样的判断。

在实际的软件开发过程中，假设你需要调用别人的模块创建一个实例，那么你需要了解这个模块内部的具体实现，了解创建模块时的各种各样的参数。此外，如果你需要维护这个模块，需要在该模块下创建一种新的实例，势必要修改原有的代码。

于是，工厂设计模式诞生了。在这种模式下，我们需要分离实例的创建与使用。换言之，我们需要构造一个工厂类，通过工厂类创建实例，供给客户使用。

##### Advantage：工厂模式的优点

人们之所以使用它是因为它有很多优点，列举如下：

- 封装性好：工厂屏蔽产品的具体实现，客户只需要了解产品的接口。
- 扩展性强：如果需要增加一种产品，只需要增加一种工厂；如果需要增加产品的一个子类，不需要修改原有代码。
- 耦合度低：在工厂模式下，实例的创建模块和使用模块被分开了，模块之间的独立性更强。

---

#### How——如何实现工厂

我们首先考虑不使用工厂的情况：

<div align = center>

![不使用工厂模式的类图](https://raw.githubusercontent.com/Jannchie/Software-Design-Pattern-Note/master/Pattern%200%20Factory%20Design%20pattern/0-1.png "不使用工厂模式的类图")

</div>

同样以汽车为例，汽车（Car）属于一个超类，它分别拥有三个子类：Lincoln、Cadillac和Buick。如果没有工厂，那么，创建汽车的的代码将会写在客户（Client）中，并且需要冗长的判断来确定究竟要创建哪一辆汽车。

为了能够屏蔽创建汽车的具体实现细节、增强扩展性、增强模块之间的独立性，我们需要实现一个汽车工厂类来进行汽车的创建。

<div align = center>

![改写为使用工厂模式](https://raw.githubusercontent.com/Jannchie/Software-Design-Pattern-Note/master/Pattern%200%20Factory%20Design%20pattern/0-2.png "改写为使用工厂模式")

</div>


工厂类一共实现了如下几个功能：

1. 选择一个汽车实体类
1. 创建该类的对象
1. 以超类的类型返回该对象

##### Disadvantage：工厂模式的缺点

工厂模式并不是在所有系统中都必须使用的设计模式，由于它也存在着一些缺点，所以我们需要考虑到实际使用工厂模式时的一些使用场景。上述实现过程中可以看出，工厂模式会使系统的复杂度和设计难度增加。每次添加一种新的产品时，都需要改变工厂类。所以值得注意的是：**简单工厂模式不符合开闭原则。**

---

#### 结语

工厂模式是一种非常常用的设计模式。在较为小型的项目中可能体会不到工厂模式的优点。但是一旦项目扩大，工厂模式就成为一种必不可少的创建实例的方式。正如工业革命建造了无数工厂极大地提高了生产力，从而使大批量生产工业产品变得可能一样，工厂模式的出现使得软件系统的扩展性更强，可维护性更高，因此使得管理庞大的项目变得可能。